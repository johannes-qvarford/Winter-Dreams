#include "SoundScape.h"
#include "GameState.h"
#include "ResourceManager.h"
#include "FileStructure.h"
#include "WindowManager.h"
#include "GameToScreen.h"
#include "PropertyManager.h"
#include <cmath>



SoundScape::SoundScape(sf::Rect<float> collisionBox, float innerRadius, int rangeDecay, float volume, bool loop, std::string soundName, bool startsEnabled, std::string soundType):
CollisionZone(startsEnabled, collisionBox, false),
mBoolEntity(false),
mInnerRadius(innerRadius),
mRangeDecay(rangeDecay),
mVolume(volume),
mLoop(loop),
mSoundType(soundType),
mSoundName(soundName),
mEnabledLastFrame(startsEnabled)


{
////////////////////////////////////////////////////////////////////////
// /FS_DIR_SOUNDS betyder: vart ligger filen, mSoundName betyder: vad heter filen
////////////////////////////////////////////////////////////////////////
	mBuffer = ResourceManager::get().getSoundBuffer(FS_DIR_SOUNDS + mSoundName);
	mSound.setBuffer(*mBuffer);
	mSound.setLoop(loop);
	mSound.setVolume(mVolume);
}

SoundScape::~SoundScape(){
	mSound.stop();
}

//////////////////////////////////////////////////////////
// /player ska bara hämtas en gång och får inte vara en weak pointer så därför görs den om till en shared pointer
//////////////////////////////////////////////////////////
void SoundScape::update(GameState* gameState){
	if (mBoolEntity == false){
		auto entity_wp = gameState->getEntity("player");
		auto entity_sp = std::shared_ptr<Entity>(entity_wp);
		auto player_sp = std::static_pointer_cast<Player>(entity_sp);
		mPlayer_wp = player_sp;
		if (getEnabled() == true){
			mSound.play();
		}
		mBoolEntity = true;
	}

//////////////////////////////////////////////////////////////////
// /när ljudet/låten stoppas så ska det inte längre vara aktiverat så att man kan aktivera de igen
//////////////////////////////////////////////////////////////////
	if (mEnabledLastFrame && mSound.getStatus() == sf::Sound::Stopped){
		setEnabled(false);
	}
	auto enabledThisFrame = getEnabled();
	
//////////////////////////////////////////////////////////////////////
// /för att ett ljud/låt ska börja att spela så behöver det gå från att inte vara aktiverad till att vara det
//////////////////////////////////////////////////////////////////////
	if (enabledThisFrame == true && mEnabledLastFrame == false){
		mSound.play();
	}
//////////////////////////////////////////////////////////////////////
// /Samma sak fast tvärtom
//////////////////////////////////////////////////////////////////////
	else if (enabledThisFrame == false && mEnabledLastFrame == true){
		mSound.stop();
	}

	std::shared_ptr<Player> player_sp(mPlayer_wp);

	sf::Rect<float> soundScapeHitBox_r = getHitBox();
	sf::Rect<float> playerHitBox_r = player_sp->getHitBox();

	sf::Vector2f soundScapeHitBox(soundScapeHitBox_r.left, soundScapeHitBox_r.top);
	sf::Vector2f playerHitBox(playerHitBox_r.left, playerHitBox_r.top);
	sf::Vector2f playerToSoundVector(playerHitBox - soundScapeHitBox);


//////////////////////////////////////////////////////////////////////
// /fullVolumeRadius är den radie som volymen ska vara satt till max i
// /distance är avståndet mellan ljudkällan och spelaren
// /maxRange är den längsta längden som det kommer höras ljud från
// /+ 0.0000001 är där för att mRangeDecay ska kunna vara 0 (bakgrundsmusik som är på hela banan)
//////////////////////////////////////////////////////////////////////
	float volume;
	float fullVolumeRadius = X_STEP * mInnerRadius;
	float distance = sqrt(playerToSoundVector.x * playerToSoundVector.x + playerToSoundVector.y * playerToSoundVector.y);
	float maxRange = (X_STEP * 100/(mRangeDecay + 0.0000001)) + fullVolumeRadius;
	float volumeModifier;

	


//////////////////////////////////////////////////////////////////////
// /beroende på vad soundTypen är så ska volymen vara olika från vad användaren 
//  har satt för värden.
// /Är soundTypen en narrator så hämtas volymen för narrator via propertyManagersfunktion getUserSettings.
// /OSV. volumeModifier delas med 100 för att få ett decimaltal som man kan gångra med mVolume senare
//////////////////////////////////////////////////////////////////////
	if (mSoundType == "narrator"){
		volumeModifier = PropertyManager::get().getUserSettings()->get<int>("narratorVolume");
		volumeModifier = volumeModifier/100;
	}
	else if (mSoundType == "sound"){
		volumeModifier = PropertyManager::get().getUserSettings()->get<int>("soundVolume");
		volumeModifier = volumeModifier/100;
	}
	else {
		volumeModifier = PropertyManager::get().getUserSettings()->get<int>("musicVolume");
		volumeModifier = volumeModifier/100;
	}


//////////////////////////////////////////////////////////////////////
// /om spelaren är innanför radien som volymen ska vara satt till max så ska ljudet vara max.
// /Annar om spelaren är utanför radien där volymen ska vara satt till max men innanför
//  längden som det ska komma någon volym ifrån så är volymen beroende av 
//  maxVolymen gånger ett tal som ska bli 0,nått beroende på vart man står 
//  maxRange - distance är för att få hur stort talet är
//  och / maxRange - fullVolumeRadius är för att få det till 0,nått
//////////////////////////////////////////////////////////////////////
	if (distance < fullVolumeRadius){
		volume = mVolume * volumeModifier;
	}
	else if (distance <= maxRange && distance >= fullVolumeRadius){
		volume = mVolume * volumeModifier * ((maxRange - distance) / (maxRange - fullVolumeRadius));
	}
	else
		volume = 0;

	mSound.setVolume(volume);

	mEnabledLastFrame = enabledThisFrame;
}

void SoundScape::drawSelf(){
	auto& manager = WindowManager::get();
	auto& window = *manager.getWindow();
	auto& states = *manager.getStates(); 

	auto& hitBox = getHitBox();
	auto position = sf::Vector2f(hitBox.left, hitBox.top);
	position = GAME_TO_SCREEN * position;


	for (int i = 0; i < 7; i++){
		position.x += i;

		sf::Vertex vertex[] = {sf::Vertex(position, sf::Color::Yellow)};
		window.draw(vertex, 1, sf::PrimitiveType::Points, states);

	}
}