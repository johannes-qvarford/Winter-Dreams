#ifndef INCLUDED_STATEMANAGER
#define INCLUDED_STATEMANAGER

#include <vector>
#include <stack>
#include <queue>
#include <memory>

class State;

////////////////////////////////////////////////////////////
// /The StateManager is a singleton that manages the different states of the game.
// /It's possible to queue actions by calling its pop/push/freeze/unfreeze methods.
// /The queue will be emptied at the end of the current frame.
////////////////////////////////////////////////////////////
class StateManager {
public:

	////////////////////////////////////////////////////////////
	// /Get the singleton.
	////////////////////////////////////////////////////////////
	static StateManager& get();

	~StateManager();

	////////////////////////////////////////////////////////////
	// /Run the game.
	////////////////////////////////////////////////////////////
	void run();

	////////////////////////////////////////////////////////////
	// /Push a new State.
	////////////////////////////////////////////////////////////
	void pushState(State* state_p);

	////////////////////////////////////////////////////////////
	// /unfreeze the top state.
	////////////////////////////////////////////////////////////
	void unfreezeState(int framesToFade = 100);

	////////////////////////////////////////////////////////////
	// /Pop and destroy the current State.
	////////////////////////////////////////////////////////////
	void popState();

	////////////////////////////////////////////////////////////
	// /freeze the top state.
	////////////////////////////////////////////////////////////
	void freezeState(int framesToFade = 90);

private:

	////////////////////////////////////////////////////////////
	// /Update the top state for one frame.
	////////////////////////////////////////////////////////////
	void updateFrame();

	////////////////////////////////////////////////////////////
	// /Update if the state of manager is normal
	////////////////////////////////////////////////////////////
	void updateNormal();

	////////////////////////////////////////////////////////////
	// /Update if the state of the manager is fading in.
	////////////////////////////////////////////////////////////
	void updateFadingIn();

	////////////////////////////////////////////////////////////
	// /Update if the state of the manager is fading out.
	////////////////////////////////////////////////////////////
	void updateFadingOut();

	////////////////////////////////////////////////////////////
	// /Darken the window with a black texture, with a provided alpha value.
	////////////////////////////////////////////////////////////
	void darkenWindow(float alpha);

	////////////////////////////////////////////////////////////
	// /Prepare the window for drawing.
	////////////////////////////////////////////////////////////
	void prepareWindow();

	////////////////////////////////////////////////////////////
	// /An Action that can be performed by the manager.
	// /if action.mTag == PUSH then action.mData.mState_p is defined
	// /else then action.mData.mNull is defined
	////////////////////////////////////////////////////////////
	struct Action { 
		enum Tag { UNFREEZE, FREEZE, PUSH, POP };
		union Data { State* mState_p; nullptr_t mNull; };
		
		Tag mTag;
		Data mData;
		int mFadeFrames;
	};

	enum StateOfManager { FADING_IN, FADING_OUT, NORMAL };

	StateManager();

	////////////////////////////////////////////////////////////
	// /No copy.
	////////////////////////////////////////////////////////////
	StateManager(const StateManager&);

	////////////////////////////////////////////////////////////
	// /No copy.
	////////////////////////////////////////////////////////////
	StateManager& operator=(const StateManager&);

	StateOfManager mStateOfManager;

	std::stack<std::unique_ptr<State> > mStates;
	
	std::queue<Action> mActions;

	int mFramesToFade;
	int mCurrentFadeFrame;
};

/*
//	Inline members.
*/

inline StateManager& StateManager::get() {
	static StateManager sMgr;
	return sMgr;
}

#endif
